FAQ
=====

This is a list of frequently asked questions on validation.

How to perform validation in Java?
-------------------------------------------------------------

First, put it into a particular scenario -- the one you're validating
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
First of all, what is validation ? For me, it's a way to check whether the current scenario can be carried out.
So this activity is inherently :doc:`contextual <inspired_by/context_specific_validation>`, that is, it's dependent on specific scenario which is validated.

Besides, it's a user-friendly way of reporting errors. If you put validation logic in domain, there is a problem of mapping error to request fields.
So I don't even bother with it. I put only fundamental checks in domain, like Price which is always positive. In case of violation,
I throw an exception without hesitation:

.. code-block:: java

    final public class Price
    {
        private Integer amount;

        public Price(Integer amount) throws Exception
        {
            if (amount < 0) {
                throw new Exception("Amount can not be empty");
            }

            this.amount = amount;
        }

        // some logic
    }

So it doesn't fit my definition of the word "validation". It's more of a `domain constraint`.

Quick example
++++++++++++++++++
Consider an food delivery order that can be registered by client online, and by an online support operator.
In the first case, there is a chance that guest will make a typo in a delivery address, and the backend system fails to find the nearest restaurant.
Is it a legal case to lose an order? I bet it's not. So it's perfectly fine to register an order even if it's not known which restaurant's gonna deliver it.
In this case, support staff finds a way to connect with a client (either by phone or an email, or, if nothing worked out, by finding his name in a client database).

Now, consider the second case: online support operator registers an order. Validation is clearly stronger. No typos are allowed, since there is no chance to fix them.
So if there is no way the backend system can find a restaurant, support staff should have the ability to set it manually somehow.

The moral of the story: don't put validation in any central place. It will hit you hard some day.

Do it declaratively
^^^^^^^^^^^^^^^^^^^^^^^^^^^
:doc:`Declarative code <inspired_by/declarative_validation>` means effectively more readable, more maintainable code.
Generally, it's the code written with what you need as a result in mind, not how exactly you should achieve it.

As an example, consider the following request (actually, some part of it) represented with the following json schema:

.. code-block:: JSON

    {
       "when":{
          "datetime":"2019-11-29 20:08:12+01:00"
       }
    }

It's a request for order delivery. There are quite a few checks we need to check, starting with json correctness,
then the structure as a whole, the required fields, their format, and further some more intricate business constraints specific to the concrete scenario:

.. code-block:: java
    :linenos:

    new FastFail<>(
        new IsJsonObject(
            new WellFormedJson(
                new IndexedValue("when", jsonString)
            )
        ),
        whenJsonElement ->
            new NamedBlocOfNameds<>(
                "when",
                List.of(
                    new RestaurantIsAbleToDeliverBySpecifiedTime(
                        new IsGreaterThan(
                            new AsDate(
                                new AsString(
                                    new Required(
                                        new IndexedValue("datetime", whenJsonElement)
                                    )
                                )
                            ),
                            new Now().value()
                        ),
                        this.dbConnection
                    )
                ),
                When.class
            )
    )
        .result();

The whole validation logic constitutes in a single expression. The whole validation is a FastFail (declared on (``Line 1``)) block, the one returning an error
if the first argument results in an error. So the first thing is to check whether it's a valid json at all (``Line 3``), then whether it's a
json object (``Line 2``). If everything's fine, a closure is invoked (``Line 7``), with the first argument being the well-formed json structure.
Then the structure itself is validated: it's a block (``Line 8``) named ``when`` (``Line 9``) consisting of other named entities. In this particular case
we expect a single key called ``datetime`` (``Line 16``). It's required (``Line 15``), turned to string (``Line 14``) and checked whether it's a valid date (``Line 13``)
which is greater than now (``Line 12``). Finally, I involve a database to find out whether some restaurant is able to deliver
this order by specified time. If all checks pass, an object of class ``When`` is created.

This code is backed by `Validol <https://github.com/wrong-about-everything/Validol>`_ library. Check out more examples in :doc:`Quick start <quick_start>` section.

Where should I put a validation logic?
-------------------------------------------------------------
e

Where should validation go in Domain-Driven Design
-------------------------------------------------------------
i

Should I throw an exception or return a bool value in validation?
---------------------------------------------------------------------
j

What is the best way to validate json in Java?
-------------------------------------------------------------
With `Validol <https://github.com/wrong-about-everything/Validol>`_, you can do it like that:

.. code-block:: java

    public class ValidatedRequest implements Validatable<JsonElement>
    {
        private String jsonRequestString;

        public ValidatedRequest(String jsonRequestString)
        {
            this.jsonRequestString = jsonRequestString;
        }

        @Override
        public Result<JsonElement> result() throws Exception
        {
            return
                new WellFormedJson(
                    new Unnamed<>(Either.right(new Present<>(this.jsonRequestString)))
                )
                    .result()
                ;
        }
    }

Chances are your request is more complicated. Your validation logic can be much more complex. I suggest that you tackle it
in a declarative fashion. For a line-by-line example take a look at :doc:`Quick-start <quick_start>` section.
Also consider having a glance at :doc:`contextual validation post <inspired_by/context_specific_validation>` and
my take on declarative programming in general and
:doc:`declarative validation <inspired_by/declarative_validation>` in particular, there you can find some more examples.

How to check whether a given string is valid JSON in Java?
-------------------------------------------------------------
f

How to validate json schema in Java?
-------------------------------------------------------------
Validating json schema can be a tedious task. Besides, take a look at validation code couple of months later after it was initially written.
It can look really scary.

There is an alternative though. With `Validol <https://github.com/wrong-about-everything/Validol>`_ library,
your validation logic mirrors json structure. Complex validation checks decorate more basic ones. Besides, an entire validation logic
represents a single `expression <https://blog.kotlin-academy.com/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0>`_.

Consider a schema to be validated:

.. code-block:: JSON

    {
       "where":{
          "building":1,
          "street":"Red Square"
       }
    }

Here is what validation logic looks like. It reflects the structure of json schema.
All the constraints are described right in the structure itself.
All the mundane checks like json key existence are already taken care of.

.. code-block:: java

    new FastFail<>(
        new IsJsonObject(
            new WellFormedJson(
                new IndexedValue("where", jsonString)
            )
        ),
        whereJsonElement ->
            new NamedBlocOfNameds<>(
                "where",
                List.of(
                    new AsString(
                        new Required(
                            new IndexedValue("street", whereJsonElement)
                        )
                    ),
                    new AsInteger(
                        new Required(
                            new IndexedValue("building", whereJsonElement)
                        )
                    )
                ),
                Where.class
            )
    )
        .result();

There is no usual spaghetti-code code here. Only pure declarative expressions.

Also, take a look at :doc:`quick-start section <quick_start>` and check my post on
:doc:`contextual validation <inspired_by/context_specific_validation>` with more examples and line-by-line analysis.


What is the best Java email address validation method?
-------------------------------------------------------------
Use `Validol <https://github.com/wrong-about-everything/Validol>`_'s
``IsEmail`` `class <https://github.com/wrong-about-everything/Validol/blob/master/src/main/java/validation/leaf/is/of/format/IsEmail.java>`_.

As usual, our example domain is order registration. Here is a request that we should validate:

.. code-block:: JSON

    {
       "guest":{
          "email":"vasya@belov.com"
       }
    }

If everything's successful, I want to have a bag of data with methods corresponding to blocks and fields in json request, like that:

.. code-block:: java

    Result<OrderRegistrationRequestData> result = new ValidatedOrderRegistrationRequest(jsonRequest).result();

    result.isSuccessful(); // true
    result.value().raw().guest().email(); // vasya@belov.com

In a course of a validation process, I want to make sure that ``guest`` is a valid json object.
That's how the whole thing looks like:

.. code-block:: java
    :linenos:

    public class ValidatedOrderRegistrationRequest implements Validatable<OrderRegistrationRequestData>
    {
        // ctor and jsonRequestString private property declaration

        @Override
        public Result<OrderRegistrationRequestData> result() throws Exception
        {
            return
                new FastFail<>(
                    new WellFormedJson(
                        new Unnamed<>(Either.right(new Present<>(this.jsonRequestString)))
                    ),
                    requestJsonObject ->
                        new UnnamedBlocOfNameds<>(
                            List.of(
                                new FastFail<>(
                                    new IsJsonObject(
                                        new Required(
                                            new IndexedValue("guest", requestJsonObject)
                                        )
                                    ),
                                    guestJsonElement ->
                                        new NamedBlocOfNameds<>(
                                            "guest",
                                            List.of(
                                                new IsEmail(
                                                    new AsString(
                                                        new Required(
                                                            new IndexedValue("email", guestJsonElement)
                                                        )
                                                    )
                                                )
                                            ),
                                            Guest.class
                                        )
                                )
                            ),
                            OrderRegistrationRequestData.class
                        )
                )
                    .result();
        }
    }

How to check whether an URL is valid in Java?
-------------------------------------------------------------
g

How to validate IPv4 string in Java
-------------------------------------------------------------
h

How to perform a validation against regex in Java?
-------------------------------------------------------------
k

How to reduce a cyclomatic complexity in validation?
-------------------------------------------------------------
l